<!DOCTYPE html>
<html>
<head>
    <title>Що таке Хеш(hash)</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@200&family=Source+Sans+Pro:wght@200;300&display=swap" rel="stylesheet">
</head>
<body>
    <div class="main-block">
        <h2 id="title">Що таке Хеш(hash)</h2>
        <hr>
        <div class="under-hr-info">
            <span id="date">2022 March 19</span>
            <a id="all-posts" href="../cryptography.html">See all posts</a>
        </div>

        <div class="text">
            <p><b>Хеш</b> - це криптографічна функція, яка перетворює будь-який обсяг інформації на унікальний набір символів, який притаманний тільки цьому масиву вхідної інформації. Цей набір символів і буде називатися хешем.</p>
            
            <h2>Трохи про криптографію</h2>
            <p>А тепер більш простою мовою. Є наука криптографія, яка займається шифруванням інформації та забезпеченням конфіденційності. Зараз ця наука має дуже велике значення в сучасному світі. У наш час усі дані шифруються. Ваші листування в соціальних мережах, банківські перекази, передача даних в інтернеті тощо. Насправді <a href="https://uk.wikipedia.org/wiki/%D0%86%D1%81%D1%82%D0%BE%D1%80%D1%96%D1%8F_%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D1%96%D1%97">криптографія</a> це стара наука, яка бере коріння ще до нашої ери. Спочатку це були досить примітивні способи приховування інформації. Але з часом наука розвивалася і приблизно 50 років тому з'явився клас алгоритмів, які неможливо зламати. Насправді їх можна зламати, наприклад <a href="https://uk.wikipedia.org/wiki/%D0%9F%D0%BE%D1%88%D1%83%D0%BA_%D0%B3%D1%80%D1%83%D0%B1%D0%BE%D1%8E_%D1%81%D0%B8%D0%BB%D0%BE%D1%8E">атакою повного перебору</a>, але кількість можливих варіантів настільки велика, що виходить за рамки адекватного часу. Наприклад, для пароля завдовжки 62 біти, в якому може використовуватися 36 символів, зі швидкістю перебору в 100 000 паролів на секунду піде приблизно півтора мільйона років. Інших відомих методів злому сучасних криптографічних алгоритмів немає. Приклади алгоритмів <a href="https://uk.wikipedia.org/wiki/RSA">RSA</a>, <a href="https://uk.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a>, <a href="https://uk.wikipedia.org/wiki/Triple_DES">3DES.</a></p>
            
            <h2>Приклади шифрування</h2>
            <p>Хеш теж належить до криптографічних алгоритмів, але в деяких моментах трохи відрізняється. Спочатку подивимося як працюють алгоритми шифрування. Для цього скористаємося шифром Цезаря (насправді це дуже старий алгоритм, який зараз не використовується, розроблений, як можна зрозуміти з назви, ще Гай Юлієм Цезарем, який жив приблизно за 50 років до н.е.), але для прикладу нам його вистачить. Отже спробуємо зашифрувати повідомлення “<i>Hello World!</i>” зі зсувом 3. Зашифрований текст вийде таким “<i>Khoor Zruog!</i>”.</p>
            <img src="./pictures/cryptography-2022-19-05_01.png" class="one_picture"></img>
            <p>Всі варіанти перестановок</p>
            <table border="1">
                <tr>
                    <th>Перетворення</th>
                    <th>Перетворений текст</th>
                </tr>
            </table>
            <table border="1">
                <tr>
                 <td>ROT0</td>
                 <td>Hello World!</td>
                 <td>ROT10</td>
                 <td>Rovvy Gybvn!</td>
                 <td>ROT20</td>
                 <td>Byffi Qilfx!</td>
               </tr>
               <tr>
                <td>ROT1</td>
                <td>Ifmmp Xpsme!</td>
                <td>ROT11</td>
                <td>Spwwz Hzcwo!</td>
                <td>ROT21</td>
                <td>Czggj Rjmgy!</td>
              </tr>
              <tr>
                <td>ROT2</td>
                <td>Jgnnq Yqtnf!</td>
                <td>ROT12</td>
                <td>Tqxxa Iadxp!</td>
                <td>ROT22</td>
                <td>Dahhk Sknhz!</td>
              </tr>
              <tr>
                <td>ROT3</td>
                <td>Khoor Zruog!</td>
                <td>ROT13</td>
                <td>Uryyb Jbeyq!</td>
                <td>ROT23</td>
                <td>Ebiil Tloia!</td>
              </tr>
              <tr>
                <td>ROT4</td>
                <td>Lipps Asvph!</td>
                <td>ROT14</td>
                <td>Vszzc Kcfzr!</td>
                <td>ROT24</td>
                <td>Fcjjm Umpjb!</td>
              </tr>
              <tr>
                <td>ROT5</td>
                <td>Mjqqt Btwqi!</td>
                <td>ROT15</td>
                <td>Wtaad Ldgas!</td>
                <td>ROT25</td>
                <td>Gdkkn Vnqkc!</td>
              </tr>
              <tr>
                <td>ROT6</td>
                <td>Nkrru Cuxrj!</td>
                <td>ROT16</td>
                <td>Xubbe Mehbt!</td>
              </tr>
              <tr>
                <td>ROT7</td>
                <td>Olssv Dvysk!</td>
                <td>ROT17</td>
                <td>Yvccf Nficu!</td>
              </tr>
              <tr>
                <td>ROT8</td>
                <td>Pmttw Ewztl!</td>
                <td>ROT18</td>
                <td>Zwddg Ogjdv!</td>
              </tr>
              <tr>
                <td>ROT9</td>
                <td>Qnuux Fxaum!</td>
                <td>ROT19</td>
                <td>Axeeh Phkew!</td>
              </tr>
            </table>
            <p>Тепер давайте зашифруємо теж повідомлення тільки без знака оклику, вийде “<i>Khoor Zruog</i>”(повну таблицю вставляти не буду, гадаю і так все очевидно), тобто ми можемо помітити, що зник тільки останній символ, але все інше залишилося таким самим. Можна ще трохи поекспериментувати, наприклад додамо трохи тексту. Тепер вихідне повідомлення буде таким “<i>Hello World. My name is Gaius Julius Caesar!</i>”, а зашифроване таким “<i>Khoor Zruog. Pb qdph lv Jdlxv Mxolxv Fdhvdu!</i>”. Давайте тепер проаналізуємо те що ми зробили, це згодом допоможе нам розібратися з хешем.</p>
            <p>Отже, перше, що можна помітити, це збільшення довжини зашифрованого повідомлення. Це і не дивно, в нас збільшився початковий текст, а значить збільшився і зашифрований. Друге що ми можемо помітити, це те що деякі частини збігаються. А саме коли ми шифрували повідомлення “<i>Hello World!</i>” у нас вийшов текст “<i>Khoor Zruog!</i>”. У доповненому варіанті перші символи в нас такі самі. Це означає, що одні й ті самі символи шифруються однаково. У принципі це логічно, інакше як би ми розшифровували потім цей текст. Але як ми побачимо далі, з хешем усе трохи інакше.</p>

            <h2>Хеш(hash)</h2>
            <p>І так, нарешті ми дійшли до хеша. Так що ж це. Якщо говорити простими словами, то це алгоритм, на вхід якому подають дані, далі він якимось чином перетворює їх, і на виході в нас виходять зовсім інші, абсолютно відмінні від початкових дані.</p>
            <p>У хеш функції є декілька важливих властивостей:</p>
            <ul>
                <li>Хеш завжди унікальний для будь-якого масива інформації.</li>
                <li>За найнезначнішої зміни вхідної інформації її хеш повністю змінюється.</li>
                <li>Хеш-функція незворотна і не дає змоги відновлювати вихідний масив інформації із символьного рядка. Це можна зробити, тільки перебравши всі можливі варіанти, кількість яких дуже велика, і за адекватний час це зробити <b>неможливо</b>.</li>
                <li>Хешування дає змогу досить швидко обчислити потрібний хеш для досить великого обсягу інформації.</li>
                <li>Хеш-функція повинна вміти приводити будь-який обсяг даних до числа заданої довжини.</li>
            </ul>
            <p>Хеш алгоритмів теж досить багато, і кожен чимось вирізняється, має свої плюси та мінуси. Найпоширеніші алгоритми сімейства SHA-2, наприклад SHA-256 який використовується в Bitcoin або в <a href="https://uk.wikipedia.org/wiki/DSA">DSA</a>(цифровий підпис). З популярних ще є SHA-1 і MD5, але для цих алгоритмів було виявлено вразливості.</p>
            
            <h2>Приклад використання хешу</h2>
            <p>Візьмемо початковий рядок “<i>Hello World!</i>”, і використаємо на ньому SHA-256. Отриманий хеш буде наступним “<i>7f83b1657ff1fc53b92dc18148a1d65dfc2d4b1fa3d677284addd200126d9069</i>”. (Ви можете самі поекспериментувати з хешами <a href="https://emn178.github.io/online-tools/sha256.html">посилання</a>).</p>
            <img src="./pictures/cryptography-2022-19-05_02.png" class="one_picture"></img>
            <p>Як можна побачити, ми отримали якийсь незрозумілий набір символів, <b>довжиною 64</b>. Щоб перевірити всі властивості хешів, давайте трохи модернізуємо вихідний текст, наприклад заберемо останній символ(знак оклику). Отриманий хеш тепер такий “<i>a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e</i>”. Давайте їх порівняєм:</p>
            <img src="./pictures/cryptography-2022-19-05_03.png" class="one_picture"></img>
            <p>Як ми бачимо, вони повністю різні. Тобто це не як у випадку з шифром Цезаря, де ми прибрали один символ і все що до нього, залишилося колишнім, а після - змінилося (у випадку з шифром Цезаря просто б зникло, бо довжина вихідного рядка зменшилася). Тут все не так, навіть найменша зміна вихідного тексту, <u>кардинально змінює захешований</u>. Також ми можемо помітити, що не змінилася і довжина хеша, хоча вихідний текст ми скоротили на один символ. Давайте проведемо ще два тести. Отримаємо хеш від повідомлення довжиною 1, і від якогось великого повідомлення.</p>
            <img src="./pictures/cryptography-2022-19-05_04.png" class="one_picture"></img>
            <p>Як ми бачимо, хеш, як і раніше, довжиною 64 символи.</p>
            <img src="./pictures/cryptography-2022-19-05_05.png" class="one_picture"></img>
            <p>Тут як вхідний текст взято визначення хеш-функції з англійської <a href="https://en.wikipedia.org/wiki/Hash_function">Вікіпедії</a>. Довжина вхідних даних 989 символів.</p>
            <p>Отже, подивимося ще раз. Довжина хеша не залежить від довжини вхідного повідомлення. Також ми бачимо, що сам хеш теж дуже сильно відрізняється, навіть за найменших змін вхідних даних. Також важливою властивістю буде те, що обчислити хеш із вхідного повідомлення дуже просто, але навпаки практично неможливо (тільки повним перебором).</p>

            <h2>Де використовується хеш</h2>
            <p>Областей, у яких використовується хеш, дуже багато. Одна із них - зберігання паролів. Наприклад є якийсь сайт, на якому можна зареєструватися. Як зазвичай відбувається реєстрація на сайті? Ви вводите логін(свій email зазвичай) і пароль, інколи потрібно вказати ще якісь параметри(наприклад ім'я і прізвище, вік і т.п.), але зараз це неважливо. Всі ці дані, а саме логін і пароль зберіграються в базі даних(<a href="https://habr.com/ru/post/555760/">БД</a>). При авторизації дані, які вводить користувач, звіряються з тими, що зберігаються в БД, і якщо вони збігаються - авторизація успішна. У всій цій системі є один недолік. Ваші дані зберігаються в незахищеному вигляді. Тобто можлива така ситуація, що базу даних сайту зламає якийсь зловмисник і вкраде звідти всі логіни та паролі користувачів. Чим це загрожує: ну по-перше, у нього тепер є доступ до облікових записів усіх користувачів цього сайту. Що вже досить проблемна ситуація, оскільки якщо це якийсь форум, то злом облікового запису користувача не такий страшний, але якщо це банківський рахунок, то у людини можуть вкрасти всі гроші. Але є ще одна проблема, більшість людей використовують в інтернеті один і той самий пароль і email(тобто вони придумали якийсь пароль, нехай навіть він буде складний) і за допомогою нього реєструються на всіляких сервісах, при цьому навіть не змінюючи його через певну кількість часу. У підсумку зловмисник отримує дані для входу не тільки до конкретно визначеного сервісу, який він зламав, а й, найімовірніше, до інших сервісів, на яких зареєстрований користувач.(найчастіше це можуть бути різні соц. мережі Instagram, Facebook, LinkedIn…). </p>
            <p>Хеш вирішує цю проблему. Адміністратору сайту можна не зберігати ваші логін і пароль. Під час реєстрації користувача йому достатньо записати в БД логін, а замість пароля записати хеш. Під час авторизації користувач вводить усе той самий логін і пароль. Сайт порівнює логін із тим логіном, який є в нього в БД, замість пароля він бере його хеш і порівнює з тим, що в нього збережено. Чим це краще? Тепер у разі злому БД сайту, зловмисник зможе отримати всі логіни користувачів, але не зможе отримати їхні паролі, тому що їх просто немає у сайту. Якось отримати пароль з хеша теж не вийде, як ми знаємо захеширувати якусь інформацію легко, але отримати вихідні дані дуже складно(потрібно перебрати всі можливі варіанти, яких <b>ДУЖЕ БАГАТО</b>).</p>
            <p>Ще одним застосуванням хеш алгоритмів може слугувати перевірка контрольної суми файлу. Уявіть, що ви завантажуєте файл з інтернету, але під час цього процесу стався якийсь збій, і ваш файл пошкодився. Це не так страшно, тому що ви, найімовірніше, не зможете його використовувати, оскільки буде порушено його цілісність. У такому випадку ви можете просто заново його завантажити. Але може бути й інша ситуація. Наприклад, якась людина (ваш знайомий) хоче передати вам якийсь файл і для цього виклала його на файлообмінник, щоб ви його звідти могли завантажити. Але доступ до цього файлообмінника має не тільки він, а ще якийсь зловмисник, і він узяв і видалив файл вашого знайомого, і встановив туди свій - "поганий" файл. Наприклад вірус. Далі ви завантажуєте собі цей файл, і тепер у вас на пристрої шкідлива програма.</p>
            <p>Як таку проблему вирішує хеш. Власник файлу може взяти від нього хеш (оскільки будь-який файл це по суті інформація, набір якихось символів) і разом із файлом надавати для скачування текстовий документ, у якому буде записано цей хеш. Після скачування файлу користувачем, він також може отримати хеш цього файлу і порівняти його з вихідним (адже ми знаємо, що навіть найменша зміна інформації призведе до кардинальних змін хеша). Це може запобігти такій проблемі, що під час завантаження стався якийсь збій, і файл завантажився неправильно. Можна зробити інакше, власник не даватиме завантажити хеш свого файлу, оскільки під час завантаження він теж може пошкодитися або його може перехопити зловмисник і змінити на свій розсуд. Власник може викласти хеш на своєму сайті, щоб користувач, який завантажив файл, зміг порівняти хеш свого файлу з тим, що є на сайті власника. Це більш безпечно.</p>
            <p>Також хеш активно застосовується в галузі криптовалют. А саме в блокчейн(<a href="https://uk.wikipedia.org/wiki/%D0%91%D0%BB%D0%BE%D0%BA%D1%87%D0%B5%D0%B9%D0%BD">blockchain</a>). Блокчейн як зрозуміло з назви це ланцюжок блоків. Блок, простіше кажучи, це безліч транзакцій, які здійснили користувачі - об'єднані в одну цілісну структуру. Для безпеки в кожному блоці зберігається хеш попереднього блоку. У такому разі якщо хтось захоче змінити n-ий блок, то йому потрібно буде змінити всі попередні блоки аж до самого першого, оскільки в кожному блоці зберігається інформація про попередній.</p>
            <p>Насправді це не всі варіанти застосування хеша, одна з популярних сфер - це цифрові підписи.</p>

            <h2>Проблеми хеш алгоритмів</h2>
            <p>Напевно основною проблемою хеш-алгоритмів є колізії. Колізія це коли два різні набори вхідних даних, мають однаковий хеш. Я наведу приклад колізії на реальних даних, а не на абстрактних рядках. У нас є два різних фото:</p>
            <img src="./pictures/cryptography-2022-19-05_06.jpg" width="750" height="500" class="one_picture"></img>
            <p>Перше фото якогось затонулого корабля</p>
            <img src="./pictures/cryptography-2022-19-05_07.jpg" width="750" height="500" class="one_picture"></img>
            <p>Друге літака</p>
            <p>На перший погляд абсолютно різні фотографії, але вони мають однаковий хеш, а саме “<i>253dd04e87492e4fc3471de5e776bc3d</i>”. Ви можете самі це перевірити, зберігши цих два фото і перевіривши їх через цей <a href="https://emn178.github.io/online-tools/md5_checksum.html">сайт</a>(або будь-який інший).</p>
            <p>То що поганого в цих колізіях. Наприклад, якщо хеш-функція використовується для створення цифрового підпису, то вміння знаходити для неї колізії фактично рівносильно вмінню підробляти цифровий підпис. Тому мірою криптостійкості хеш-функції вважається обчислювальна складність знаходження колізії. В ідеалі не повинно існувати способу відшукання колізій швидшого, ніж повний перебір. Якщо для деякої хеш-функції знайдено спосіб отримання колізій істотно швидший, ніж повний перебір, то ця хеш-функція перестає вважатися криптостійкою і використовуватися для передавання та зберігання секретної інформації.</p>
            <p>Інший приклад - кілька користувачів на якомусь сайті мають однакові паролі, то, зламавши один хеш, ми отримуємо доступ до всіх акаунтів, де використовується той самий пароль. Для прикладу: нехай у нас кілька тисяч користувачів, напевно кілька з них використовують пароль “<i>123456</i>” (якщо налаштування сайту не змушують ускладнювати пароль). MD5-хеш для цього пароля “<i>e10adc3949ba59abbe56e057f20f883e</i>”. Тож якщо ви роздобудете цей хеш і пошукаєте в базі даних за цим значенням, то знайдете всіх користувачів із таким паролем.</p>
            <p>Чому колізії виникають? Одна з властивостей хешу, це фіксована довжина вихідного повідомлення. Наприклад, кількість різних варіантів хешу певного алгоритму дорівнює 4 мільярдам. А в нас є 5 мільярдів вхідних повідомлень, тоді очевидно, що деякі з різних вхідних повідомлень матимуть однакові хеші, просто тому що їх більше, ніж кількість усіляких хеш-значень.</p>

        </div>
    </div>    
</body>
</html>