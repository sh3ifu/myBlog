<!DOCTYPE html>
<html>
<head>
    <title>Вразливість в смарт-контракті аукціону(Solidity by Example)</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@200&family=Source+Sans+Pro:wght@200;300&display=swap" rel="stylesheet">

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <div class="main-block">
        <h2 id="title">Вразливість в смарт-контракті аукціону(Solidity by Example)</h2>
        <hr>
        <div class="under-hr-info">
            <span id="date">2024 May 13</span>
            <a id="all-posts" href="../blockchain.html">See all posts</a>
        </div>

        <div class="text">
          <p>Аукціони, стародавні форми торгівлі, продовжують залишатися актуальними в сучасному цифровому світі. Зокрема, завдяки еволюції технологій блокчейну та смарт-контрактів. Смарт-контракти, як невід'ємна частина блокчейну, надають новий рівень ефективності, безпеки та довіри в аукціонній сфері.</p>
          <p>Сучасні аукціони, такі як <a href="https://opensea.io/">OpenSea</a>, народжені в цифрову епоху, відкривають безмежні можливості для торгівлі мистецтвом, цифровими активами та іншими цінностями. Вони дозволяють учасникам з усього світу швидко та ефективно купувати та продавати, маючи доступ до широкого асортименту товарів.</p>
          <p>Що стосується роботи аукціонів, існують різноманітні типи, які варіюються від англійського аукціону до <a href="https://uk.wikipedia.org/wiki/%D0%93%D0%BE%D0%BB%D0%BB%D0%B0%D0%BD%D0%B4%D1%81%D1%8C%D0%BA%D0%B8%D0%B9_%D0%B0%D1%83%D0%BA%D1%86%D1%96%D0%BE%D0%BD#:~:text=%D0%BE%D1%87%D1%96%D0%BA%D1%83%D1%94%20%D0%BD%D0%B0%20%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D1%96%D1%80%D0%BA%D1%83.-,%D0%A1%D1%82%D0%B0%D0%B1%D1%96%D0%BB%D1%8C%D0%BD%D1%83%20%D0%B2%D0%B5%D1%80%D1%81%D1%96%D1%8E%20%D0%B1%D1%83%D0%BB%D0%BE%20%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D1%96%D1%80%D0%B5%D0%BD%D0%BE%205%20%D0%B3%D1%80%D1%83%D0%B4%D0%BD%D1%8F%202022.,%D0%BF%D0%BE%D0%BA%D1%83%D0%BF%D0%B5%D1%86%D1%8C%2C%20%D1%8F%D0%BA%D0%BE%D0%BC%D1%83%20%D1%96%20%D0%BF%D1%80%D0%BE%D0%B4%D0%B0%D1%94%D1%82%D1%8C%D1%81%D1%8F%20%D1%82%D0%BE%D0%B2%D0%B0%D1%80.">голландського</a> та <a href="https://en.wikipedia.org/wiki/Japanese_auction">японського</a>. Однак, серед них особливе місце займає саме англійський аукціон, що визначається своєю відкритістю та зростаючою ціною лота. Смарт-контракти стають ключовим інструментом в реалізації таких аукціонів, забезпечуючи прозорість, автоматизацію та безпеку для всіх учасників.</p>
          <p>У цій статті ми розглянемо одну вразливість в реалізації смарт-контракту англійського аукціону, яку я знайшов на сайті <a href="https://solidity-by-example.org/app/english-auction/">Solidity by Example</a>. Цей сайт з прикладами різних контрактів призначений для людей вивчаючих мову програмування Solidity. Вони можуть подивитися на реалізацію різних принципів та стандартів, які зараз популярні в децентралізованих фінансах. Звичайно він не є бібліотекою верифікованих безпечних смарт-контрактів, які пройшли аудити як наприклад <a href="https://www.openzeppelin.com/">OpenZeppelin</a>, але початківці можуть використовувати приклади з нього не просто для практики але і в реальних проектах. Тому на мою думку варто звернути увагу на ті вразливості які там є, щоб користувачі знали про них і могли виправити.</p>
          <blockquote>
            <i>Будь яка вразливість в контракті, це потенційна загроза для коштів користувачів та власників. Тому варто з особливою прискіпливістю проводити перевірку безпеки.</i>
          </blockquote>

          <h2>Як працює англійський аукціон</h2>
          <p>Англійський аукціон, є одним з найпоширеніших типів аукціонів у світі та відзначається своєю простотою та прозорістю.</p>
          <p>Механізм англійського аукціону полягає в послідовному підвищенні ціни на лоти до тих пір, поки не буде досягнуто максимальної прийнятної ціни для покупця. Учасники аукціону по черзі підвищують ціну, доки не залишиться тільки один покупець, готовий заплатити найвищу суму за лот. Переможець аукціону — той, хто зробив останню (найвищу) ставку перед завершенням аукціону.</p>
          <p>Процес англійського аукціону може бути відкритим або закритим, залежно від конкретних умов та правил, встановлених організатором. Відкритий аукціон передбачає публічне оголошення ставок, тоді як закритий аукціон може вимагати від учасників подання ставок конфіденційно.</p>
          <p>Смарт-контракти, як ключовий елемент децентралізованного аукціонного процесу, можуть автоматизувати і контролювати всі етапи торгівлі, включаючи прийом ставок, визначення переможця та виконання угоди. Це забезпечує велику ступінь довіри та прозорості серед учасників аукціону та гарантує дотримання умов угоди.</p>

          <h2>Реалізація англійського аукціону від Solidity by Example</h2>
          <p>Повний код контракта:</p>
          <div class="iframe_center">
            <iframe src="https://ethfiddle.com/services/iframesnippet/8ajFOMmT2s" scrolling="yes" frameborder="0" height="1000" width="300" style="width: 70%;"></iframe>
          </div>
          <h3>Розглянемо основні моменти в цьому контракті</h3>
          <p>Інтерфейс для взаємодії з NFT.</p>
          <div class="iframe_center">
            <iframe src="https://ethfiddle.com/services/iframesnippet/dbmU0W42cq" scrolling="no" frameborder="0" height="130" width="300" style="width: 55%;"></iframe>
          </div>
          <p>Змінні в яких зберігається інформація про аукціон: дані про NFT, адреса продавця, адреса учасника який поставив найбільшу ставку, розмір найбільшої ставки, коли починається та закінчується аукціон і т.д.</p>
          <div class="iframe_center">
            <iframe src="https://ethfiddle.com/services/iframesnippet/nzjCR-tkpM" scrolling="no" frameborder="0" height="260" width="300" style="width: 30%;"></iframe>
          </div>
          <p>В конструкторі задається початкова інформація про аукціон: адреса NFT контракту, NFT id а також початкова ціна.</p>
          <div class="iframe_center">
            <iframe src="https://ethfiddle.com/services/iframesnippet/ghXgFfTiC2" scrolling="no" frameborder="0" height="185" width="300" style="width: 40%;"></iframe>
          </div>
          <p>Також функції початку аукціону <b>start</b>(яку може викликати тільки продавець) та виведення <b>withdraw</b>(потрібна щоб учасники, які не виграли аукціон могли повернути свої кошти).</p>
          <p>Розглянемо функцію ставки:</p>
          <div class="iframe_center">
            <iframe src="https://ethfiddle.com/services/iframesnippet/VV9NPLgM68" scrolling="no" frameborder="0" height="300" width="300" style="width: 40%;"></iframe>
          </div>
          <p>Спочатку йде декілька перевірок:</p>
          <ol>
            <li><b>Перевірка на початок аукціону</b> - можлива така ситуація, що користувач захоче поставити ставку ще до того як сам аукціон розпочне продавець - такого не повинно бути.</li>
            <li><b>Перевірка на закінчення аукціону</b> - в функції старт задається тривалість(7 днів), до цього моменту ніхто(навіть власник контракту) не може закінчити аукціон. На протязі цього часу будь-які користувачі можуть ставити свої ставки(головне щоб кожна нова ставка була більша за попередню). Оскільки щоб закінчити аукціон, потрібно викликати відповідну функцію(це може зробити будь хто, головне щоб настав час), може виникнути така ситуація, що цю функцію ще ніхто не викликав, отже відповідний прапорець <b>bool public ended;</b> матиме значення <b>false</b>. Для цього і існує ця перевірка, навіть якщо ще ніхто не викликав функцію <b>end</b>, користувач все одно не зможе поставити ставку, якщо час для цього вже пройшов.</li>
            <li><b>Перевірка розміру ставки</b> - потрібна щоб відсіювати ті ставки, які менші за поточну найвищу ставку.</li>
          </ol>
          <p>Далі записуються у відповідні змінні значення найвищої ставки та адреса того хто її поставив.</p>
          <p>Перейдемо до функції закінчення аукціону.</p>
          <div class="iframe_center">
            <iframe src="https://ethfiddle.com/services/iframesnippet/kqq--cGM1a" scrolling="no" frameborder="0" height="345" width="300" style="width: 45%;"></iframe>
          </div>
          <p>Тут в нас також є декілька перевірок:</p>
          <ol>
            <li><b>Перевірка на початок аукціону</b> - можливо аукціон ще не розпочали, а його вже хочуть закінчити.</li>
            <li><b>Перевірка на передчасне закінчення аукціону</b> - запобігає передчасному закінченню аукціону(тобто в даному випадку до завершення періоду в 7 днів).</li>
            <li><b>Перевірка на закінчення аукціону</b> - потрібна щоб запобігти ситуації коли хтось повторно захоче викликати цю функцію(навіщо закінчувати аукціон, якщо він і так вже закінчений).</li>
          </ol>
          <p>Далі встановлюється прапорець який означає закінечення аукціону. Після цього відбується ще одна перевірка на <a href="https://stackoverflow.com/questions/48219716/what-is-address0-in-solidity">нульовий адрес</a> в тілі якої в використовується функція <b>safeTransferFrom</b> визначена в стандарті <a href="https://eips.ethereum.org/EIPS/eip-721">ERC721</a>.</p>
          <p>Цю функцію розглянемо детальніше, оскільки вона є причиною вразливості в контракті. На відміну від іншої функції зі схожим значенням <b>transferFrom</b>, перша перевіряє адрес на який передається токен і якщо це адрес контракту, то перевіряє чи в ньому реалізована функція <b>onERC721Received</b>. Для чого це потрібно? Давайте спочатку розглянемо реалізацію <b>transferFrom</b>:</p>
          <div class="iframe_center">
            <iframe src="https://ethfiddle.com/services/iframesnippet/urM1HI9vl5" scrolling="no" frameborder="0" height="290" width="300" style="width: 45%;"></iframe>
          </div>
          <p>В коді ми бачимо що, в нас йдуть три перевірки:</p>
          <ol>
            <li><b>Перевірка відправляючого</b> - очевидно що право на передачу NFT має тільки власник цього токену(якщо звичайно він не надав таку можливість ще комусь) а не будь хто, хто просто викликав цю функцію.</li>
            <li><b>Перевірка на нульовий адрес</b> - відправка на неіснуючий адрес, це вже механізм <a href="https://support.immutable.com/en/articles/8979235-burning-an-nft">спалювання</a>, тобто зовсім не те що потрібно.</li>
            <li><b>Перевірка дозволу на відправку</b> - можлива така ситуація, що власник надав права на передачу токена комусь іншому. Тому в функції <b>_isApprovedOrOwner</b> перевіряється, чи має право на передачу ініціатор транзакції.</li>
          </ol>
          <p>Далі йде код який відповідає за передачу NFT.</p>
          <p>Звичайні користувачі можуть взаємодіяти з NFT за допомогою свої гаманців. Але як щодо контрактів? Вони ж також мають свої адреси, отже на них можна відправити як ефір так і інші токени. Можлива така ситуація що хтось захоче передати невзаємозамінний токен на адресу контракту який немає прописаного функціоналу щоб взаємодіяти з ним. Оскільки контракт після розгортання в блокчейні вже не можна змінити, виходить що NFT відправлене на такий контракт можна сказати зникне. Тобто формально воно звичайно буде зберігатись на аккаунті цього контракту, але ніхто не зможе з ним нічого зробити.</p>
          <p>Щоб не виникало таких ситуацій, була створена функція <b>safeTransferFrom</b>.</p>
          <div class="iframe_center">
            <iframe src="https://ethfiddle.com/services/iframesnippet/lKK8HkUcB8" scrolling="no" frameborder="0" height="240" width="300" style="width: 53%;"></iframe>
          </div>
          <p>Можна побачити що вона не сильно відрізняється від оригінальної функції <b>transferFrom</b>. Тобто вона викликає звичайну передачу(на <a href="https://ethereum.org/en/developers/docs/accounts/">EOA</a> адреси) токена попередньої функції, а сама ще додатково перевіряє: чи не являється адрес якому передають NFT, адресою контракта. Якщо так, то далі вона перевіряє чи реалізована функція <b>onERC721Received</b> в тому контракті, якому намагаються передати токен.</p>
          <p>Може виникнути питання, чому спочатку викликається функція <b>transferFrom</b> а тільки потім відбувається перевірка адресу. Все просто, якщо виявиться, що адрес якому намагаються передати NFT це адрес контракта, і якщо в ньому <u>не реалізована</u> функція <b>onERC721Received</b>, то <b>require</b> виконає <b>revert</b> і вся транзакція відкатиться(тобто передача не відбудеться). Якщо ж перевірка пройде успішно, то виконається <b>transferFrom</b> і функція завершиться.</p>

          <h2>Підготовка</h2>
          <p>Щоб краще зрозуміти весь механізм, будемо робити все по порядку.</p>
          <blockquote>
            <i>Всі дії будуть відбуватись в RemixIDE.</i>
          </blockquote>
          <p>Розгорнемо в локальний блокчейн контракт з NFT.</p>
          <img src="https://www.dropbox.com/scl/fi/olxcd7im15eg49b347sag/blockchain-2024-13-05_01.png?rlkey=jit6o2c1r97rco53suwa1hn8j&st=s3vbu694&dl=1" width="1000" class="one_picture"></img>
          <p class="one_caption">Рис. 1 Розгортання NFT-контракту в локальний блокчейн RemixIDE</p>
          <p>Адрес <b>0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</b> буде використовуватись для розгортання контрактів NFT та аукціону. Також він буде першим власником NFT.</p>
          <p>Після розгортання одразу ж виконаємо "мінт" токена на той самий адрес. Він буде мати <b>id 0</b>.</p>
          <img src="https://www.dropbox.com/scl/fi/uo4hjuem15rmgnsaieu10/blockchain-2024-13-05_02.png?rlkey=yl1kbbqtpp86g9wcep40c1awj&st=2ipwtxb0&dl=1" width="1000" class="one_picture"></img>
          <p class="one_caption">Рис. 2 Розгортання контракту аукціону</p>
          <p>Отже в конструкторі контракту аукціону вказуємо адресу контракта NFT, id який дорівнює 0 і початкову ціну(для тесту неважливо яка саме початкова ціна буде встановлена, тому я вказав 1 wei).</p>
          <p>Після розгортання контракту аукціону потрібно надати дозвіл на переказ NFT цьому контракту.</p>
          <img src="https://www.dropbox.com/scl/fi/vfec7by0xwant22a753wg/blockchain-2024-13-05_03.png?rlkey=w0nb1q9yfoyu5cz9alf30utxz&st=fe6zxxwz&dl=1" width="600" class="one_picture"></img>
          <p class="one_caption">Рис. 3 Виклик функції approve в контракті NFT для надання дозволу на переведення</p>
          <blockquote>
            <i>В оригінальному контракті термін торгів аукціону становить 7 днів. Я змінив його до 3 хв, щоб не чекати цілий тиждень.</i>
          </blockquote>
          <p>Коли власник аукціона викличе функцію <b>start</b>, NFT яку він хоче продати перейде у володіння аукціону.</p>
          <p>Далі розгорнемо контракт атаки, його код ми розлянемо детальніше в наступному розділі.</p>

          <h2>Виконання атаки</h2>
          <p>Повернемось ще раз до функції <b>end</b> з контракту <i>EnglishAuction</i>.</p>          
          <div class="iframe_center">
            <iframe src="https://ethfiddle.com/services/iframesnippet/_y2hEFlXv9" scrolling="no" frameborder="0" height="330" width="300" style="width: 45%;"></iframe>
          </div>
          <p>Як вже вище згадувалось, вся проблема в рядку <b>nft.safeTransferFrom(address(this), highestBidder, nftId);</b>. Оскільки передача токену відбувається за допомогою більш "безпечної" функції, зловмисник може вчинити таку атаку.</p>
          <p>Створити смарт-контракт який розмістить найбільшу ставку і відповідно виграє аукціон. Далі при виклику функції <b>end</b> повинен виконатись код для передачі NFT переможцю і виведенню коштів на адресу продавця. Але оскільки атакуючий контракт не реалізує функції <b>onERC721Received</b>, функція <b>safeTransferFrom</b> виконає <b>revert</b> а отже вся транзакція відкатиться.</p>
          <p>Відповідно власник NFT не отримає свої кошти, а NFT назавжди зависне на контракті аукціону.</p>
          <p>Тепер розглянемо код контракту атаки.</p>
          <div class="iframe_center">
            <iframe src="https://ethfiddle.com/services/iframesnippet/faBzO7s_jD" scrolling="no" frameborder="0" height="320" width="300" style="width: 45%;"></iframe>
          </div>
          <p>Інтерфейс потрібен для того, щоб контракт атаки знав які функції реалізовані в контракті аукціону. <b>receive</b> потрібний щоб можна було перевести ефір для атаки. Функція <b>callBid</b> отримує параметром адресу контракту аукціону і викликає функцію <b>bid</b>, передаючи їй 3 ефіра.</p>
          <p>Тепер перейдемо до виконання цієї атаки. Я додатково ще поставлю ставки в розмірі 1 та 2 ефірів з цих аккаунтів <b>0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2</b>, <b>0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db</b> для імітації справжніх торгів. Отже загальний баланс буде <u>3 ефіра</u>, а найвища ставка <u>2 ефіра</u>. Після чого я викличу функцію <b>callBid</b> з атакуючого контракту, вона в свою чергу викличе функцію <b>bid</b> з контракту аукціону і цим самим поставить найвищу ставку.</p>
          <img src="https://www.dropbox.com/scl/fi/fja6pq5oc3pv1c9utvqjk/blockchain-2024-13-05_04.png?rlkey=17o5efnfo1zd2zfy9nkbt6mwz&st=x0qycb9d&dl=1" width="1100" class="one_picture"></img>
          <p class="one_caption">Рис. 4 Імітація ставок</p>
          <p>Ставки поставлені, загальний баланс на контракті зараз становить 3 ефіра. Отже найвища ставка зараз 2 ефіра, відправлена цим адресом <b>0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db</b>.</p>
          <img src="https://www.dropbox.com/scl/fi/5863syvrulh465u2cn38r/blockchain-2024-13-05_05.png?rlkey=3mp60jhwez2fki868btztlmzx&st=m95rbrkg&dl=1" width="400" class="one_picture"></img>
          <p class="one_caption">Рис. 5 Баланси акаунтів</p>
          <p>На останньому аккаунті -3 ефіра, тому що він переводив їх на контракт атаки.</p>
          <img src="https://www.dropbox.com/scl/fi/zl3onrp9njamvymejtpb7/blockchain-2024-13-05_06.png?rlkey=6c1odxg7ztz08x881amw295tl&st=sefm6tpv&dl=1" width="500" class="one_picture"></img>
          <p class="one_caption">Рис. 6 Проведення атаки</p>
          <p>Далі викликаємо функцію <b>callBid</b> з атакуючого контракту, він робить ставку в розмірі 3-х ефірів і оскільки більше ніхто після нього не робив ставок, він стає переможцем.</p>
          <img src="https://www.dropbox.com/scl/fi/6aof08im5qkkjij9e0ah4/blockchain-2024-13-05_07.png?rlkey=e9ehkwuhgdavnwmvydfgtddpk&st=7ed05foj&dl=1" width="600" class="one_picture"></img>
          <p class="one_caption">Рис. 7 Результат проведення атаки</p>
          <p>Тепер будь хто може викликати функцію <b>end</b>, щоб завершити аукціон.</p>
          <img src="https://www.dropbox.com/scl/fi/f5i3weq7c1qr8sbcumg2o/blockchain-2024-13-05_08.png?rlkey=0y1jk8nqtx47mq4dp4wp6gjcp&st=n8etxlfy&dl=1" width="1100" class="one_picture"></img>
          <p class="one_caption">Рис. 8 Результат виклику функції end</p>
          <p>Як ми бачимо транзакція не виконалась. Відповідно адреса власника NFT залишилась та сама(тобто власником залишився аукціон), кошти які мали бути відправлені продавцю також залишились на контракті. Єдині хто можуть вивести свою криптовалюту, це всі користувачі які поставили попередні(менші) ставки(вони це можуть зробити за допомогою функції <b>withdraw</b>). Токен і ефір поставлений найвищою ставкою назавжди застрягли на цьому контракті.</p>
          <p>Про доцільність такої атаки важко говорити, тому що зловмисник сам втрачає свої кошти без права повернення. Можливо, хакер таким чином хоче "спалити" цю NFT, будучи готовим при цьому пожертвувати своєю криптовалютою. Тим не менш, про цю вразливість потрібно знати, оскільки не можна повністю опиратись на фінансову вигоду, яка, як може здатись, запобігає проведенню цієї атаки зловмисником. Незрозуміло, який план та мотиви у особи, що проводить атаку, можливо, блокування цієї NFT важливіше втрачених грошей.</p>

          <h2>Виправлення вразливості</h2>
          <p>Як ми побачили вище, вразливість всього в одному рядку цілого смарт-контракту, може привести до досить неприємних наслідків. Варто дуже ретельно перевіряти контракт на наявність помилок або потенційних проблем перед розгортанням в блокчейн. Особливо якщо він призначений для роботи з власними коштами, чи тим більше - користувачів.</p>
          <p>Найбільш очевидний варінат виправлення цієї вразливості, це просто замінити функцію <b>safeTransferFrom</b> на <b>transferFrom</b>. Тим самим делегувавши відповідальність за прийом токена на сторону користувача.</p>
          <p>Ще одним варіантом є написання додаткового функціоналу для виведення токену(назад продавцеві) та повернення коштів переможцю, через деякий час. Тобто наприклад, якщо на протязі 7 днів на адрес який виграв аукціон, не виведено NFT, то продавець може викликати спеціальну фукнцію, щоб все повернути.</p>          
          <br>
          <br>
        </div>
    </div>    
</body>
</html>